import _ from "lodash";
import { Section, SectionGrid, Texts } from "../../../domain/common/entities/DataForm";
import { DataElement } from "../../../domain/common/entities/DataElement";
import { titleVariant } from "../../../domain/common/entities/TitleVariant";
import { Maybe } from "../../../utils/ts-utils";
import { getFormulaByColumnName, Summary, TotalItem } from "./GridWithCatOptionCombosViewModel";
import { DataFormInfo } from "./AutogeneratedForm";
import { getDescription } from "../../../utils/viewTypes";
import { getIndicatorRelatedToDataElement, Indicator } from "../../../domain/common/entities/Indicator";

export interface Grid {
    dataElements: Array<DataElement & { indicator: Maybe<Indicator> }>;
    id: string;
    name: string;
    columns: Column[];
    rows: Row[];
    toggle: Section["toggle"];
    toggleMultiple: Section["toggleMultiple"];
    useIndexes: boolean;
    texts: Texts;
    titleVariant: titleVariant;
    summary: Maybe<Summary>;
    indicators: Indicator[];
}

interface SubSectionGrid {
    name: string;
    dataElements: DataElement[];
}

interface Column {
    name: string;
    description?: string;
    isSourceType: boolean;
}

export interface Row {
    indicator: Maybe<Indicator>;
    includePadding: number;
    name: string;
    htmlText: string;
    items: Array<{
        column: Column;
        columnTotal: Maybe<DataElement>;
        columnDataElements: DataElement[];
        dataElement: Maybe<DataElement>;
        disabled: boolean;
        disableComments: boolean;
    }>;
}

const separator = " - ";

export class GridViewModel {
    static get(section: SectionGrid, dataFormInfo: DataFormInfo): Grid {
        const dataElementsConfig = dataFormInfo.metadata.dataForm.options.dataElements;
        const dataElements = getDataElementsWithIndexProccessing(section);

        const subsections = _(dataElements)
            .groupBy(dataElement => getSubsectionName(dataElement))
            .toPairs()
            .map(
                ([groupName, dataElementsForGroup]): SubSectionGrid => ({
                    name: groupName,
                    dataElements: dataElementsForGroup.map(dataElement => ({
                        ...dataElement,
                        name: _(dataElement.name).split(separator).last() || "-",
                    })),
                })
            )
            .value();

        const columns: Column[] = _(subsections)
            .flatMap(subsection => subsection.dataElements)
            .uniqBy(de => de.name)
            .map(({ id, name }) => {
                const columnDescription = getDescription(section.columnsDescriptions, dataFormInfo, name);
                const config = dataElementsConfig[id];
                return { isSourceType: isSourceTypeColumn(config?.widget), name: name, description: columnDescription };
            })
            .value();

        const dataElementsByTotal = _(section.calculateTotals)
            .groupBy(item => item?.totalDeCode)
            .map((group, totalColumn) => ({
                totalColumn,
                dataElements: group.map(item => _.findKey(section.calculateTotals, obj => obj === item)),
            }))
            .value();

        const rows = subsections.map(subsection => {
            const firstDataElement = _(subsection.dataElements).first();
            const indicator = getIndicatorRelatedToDataElement(section.indicators, firstDataElement?.code || "");
            const items = columns.map(column => {
                const dataElement = subsection.dataElements.find(de => de.name === column.name);
                const deCalculateTotal =
                    section.calculateTotals && dataElement?.code
                        ? section.calculateTotals[dataElement.code]
                        : undefined;

                const parentTotal = deCalculateTotal
                    ? dataElements.find(de => de.code === deCalculateTotal?.totalDeCode)
                    : undefined;

                const dataElementsInTotalColumn = dataElementsByTotal.find(x => x.totalColumn === parentTotal?.code);
                const columnDataElements = dataElements.filter(de =>
                    dataElementsInTotalColumn?.dataElements.includes(de.code)
                );

                return {
                    column: column,
                    columnTotal: parentTotal,
                    columnDataElements: columnDataElements,
                    dataElement: dataElement,
                    disabled: deCalculateTotal?.disabled ?? false,
                    disableComments: section.disableComments || dataElement?.disabledComments || false,
                };
            });

            const itemsWithHtmlText = _(items)
                .map(item => item.dataElement?.htmlText)
                .compact()
                .value();

            const firstItemWithHtmlText = _(itemsWithHtmlText).first() || "";

            return {
                includePadding: 0,
                indicator: indicator,
                name: subsection.name,
                htmlText: firstItemWithHtmlText,
                items: items,
            };
        });

        const useIndexes =
            _(rows).every(row => Boolean(row.name.match(/\(\d+\)$/))) &&
            _(rows)
                .groupBy(row => row.name.replace(/\s*\(\d+\)$/, ""))
                .size() === 1;

        const totals = _(columns)
            .map(column => {
                const allDataElements = subsections.flatMap(subSection => subSection.dataElements);
                const selectedDataElements = allDataElements.filter(dataElement =>
                    section.totals?.dataElementsCodes.includes(dataElement.code)
                );

                const columnWithDataElements = _(selectedDataElements)
                    .map((dataElement): Maybe<TotalItem> => {
                        if (dataElement.type !== "NUMBER") return undefined;
                        const categoryOptionCombo = dataElement.categoryOptionCombos[0];
                        if (!categoryOptionCombo) {
                            console.warn(
                                `Cannot found categoryOptionCombo in column ${column.name} for dataElement ${dataElement.code}`
                            );
                            return undefined;
                        }

                        return { dataElement, categoryOptionCombo };
                    })
                    .compact()
                    .value();

                return {
                    columnName: column.name,
                    formula: getFormulaByColumnName(section, column.name) || section.totals?.formula || "",
                    items: columnWithDataElements,
                };
            })
            .value();

        const indicatorsRelatedToDataElements = _(section.indicators)
            .map(indicator => (indicator.dataElement ? indicator.id : undefined))
            .compact()
            .value();

        return {
            id: section.id,
            indicators:
                indicatorsRelatedToDataElements.length > 0
                    ? section.indicators.filter(indicator => !indicatorsRelatedToDataElements.includes(indicator.id))
                    : section.indicators,
            name: section.name,
            columns: columns,
            rows: rows,
            toggle: section.toggle,
            toggleMultiple: section.toggleMultiple,
            texts: section.texts,
            useIndexes: useIndexes,
            titleVariant: section.titleVariant,
            summary: section.totals
                ? {
                      cellName: section.texts?.totals || "",
                      cells: totals,
                  }
                : undefined,
            dataElements: dataElements.map(dataElement => {
                const indicator = getIndicatorRelatedToDataElement(section.indicators, dataElement.code);
                return { ...dataElement, indicator };
            }),
        };
    }
}

/** Move the data element index to the row name, so indexed data elements are automatically grouped 

    Input:
        MAL - Compound name (1)
        MAL - Compound name (2)
        MAL - Compound symbol (1)
        MAL - Compound symbol (2)

    Output:
        MAL (1) - Compound name
        MAL (2) - Compound name
        MAL (1) - Compound symbol
        MAL (2) - Compound symbol
*/

function getDataElementsWithIndexProccessing(section: Section) {
    return section.dataElements.map((dataElement): typeof dataElement => {
        // "MAL - Compound name (1)" -> "MAL (1) - Compound name"
        const index = dataElement.name.match(/\((\d+)\)$/)?.[1];

        if (!index) {
            return dataElement;
        } else {
            const parts = dataElement.name.split(separator);
            const initial = _.initial(parts).join(separator);
            const last = _.last(parts);
            if (!last) return dataElement;
            const lastWithoutIndex = last.replace(/\s*\(\d+\)$/, "");
            const newName = `${initial} (${index}) - ${lastWithoutIndex}`;
            return { ...dataElement, name: newName };
        }
    });
}

function getSubsectionName(dataElement: DataElement): string {
    // Remove index from enumerated data elements (example: `Chemical name (1)` -> `Chemical name`)
    // so they are grouped with no need to edit each name in the metadata.
    return _(dataElement.name).split(separator).initial().join(separator);
}

export function isSourceTypeColumn(widget: Maybe<"dropdown" | "radio" | "sourceType">) {
    return widget === "sourceType";
}
