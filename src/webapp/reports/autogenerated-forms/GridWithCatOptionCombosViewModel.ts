import _ from "lodash";
import { Section, Texts } from "../../../domain/common/entities/DataForm";
import { DataElement } from "../../../domain/common/entities/DataElement";
import { CategoryOptionCombo } from "../../../domain/common/entities/CategoryOptionCombo";
import { Maybe } from "../../../utils/ts-utils";
import { DataFormInfo } from "./AutogeneratedForm";
import { getDescription } from "../../../utils/viewTypes";
import { Indicator } from "../../../domain/common/entities/Indicator";

export interface Grid {
    id: string;
    name: string;
    columns: Column[];
    rows: Row[];
    toggle: Section["toggle"];
    toggleMultiple: Section["toggleMultiple"];
    texts: Texts;
    summary: Maybe<Summary>;
    indicators: Indicator[];
}

interface SubSectionGrid {
    name: string;
    code: Maybe<string>;
    dataElements: DataElement[];
}

interface Column {
    name: string;
    dataElements: DataElement[];
    description?: string;
}

interface Row {
    groupName: string;
    groupDescription: Maybe<string>;
    rows: {
        dataElement: DataElement;
        deName: string;
        name: string;
    }[];
}

const separator = " - ";

export function getFormulaByColumnName(section: Section, columnName: string): Maybe<string> {
    if (!section.totals) return undefined;
    if (!section.totals.formulas) return undefined;

    const keys = Object.keys(section.totals.formulas);
    const currentColumn = keys.find(key => key.toLowerCase() === columnName.toLowerCase());
    if (!currentColumn) return section.totals.formula;

    const columnFormula = section.totals.formulas[currentColumn];
    if (!columnFormula) return section.totals.formula;

    return columnFormula.formula;
}

export class GridWithCatOptionCombosViewModel {
    static get(section: Section, dataFormInfo: DataFormInfo): Grid {
        const subsections = _(section.dataElements)
            .flatMap(dataElement => {
                const categoryOptionCombos = dataElement.categoryCombos.categoryOptionCombos;
                return categoryOptionCombos.map(coc => {
                    const categoryOptionCombo = dataElement.categoryCombos.categoryOptionCombos.find(
                        c => c.name === coc.name
                    );
                    return {
                        ...dataElement,
                        cocId: categoryOptionCombo?.id,
                        name: `${coc.name} - ${_(dataElement.name).split(separator).last()}`,
                        fullName: dataElement.name,
                        cocName: coc.formName ?? coc.name,
                        catOptionCode: _(coc.categoryOptions).first()?.code || "",
                    };
                });
            })
            .filter(dataElement => dataElement.cocId !== undefined)
            .groupBy(dataElement => `${dataElement.cocName}--${dataElement.catOptionCode}`)
            .toPairs()
            .map(([groupName, dataElementsForGroup]): SubSectionGrid => {
                const [name, code] = groupName.split("--");
                if (!name) throw Error(`Cannot find column name: ${name}`);
                return {
                    name: name,
                    code: code,
                    dataElements: dataElementsForGroup.map(dataElement => ({
                        ...dataElement,
                        name: dataElement.fullName,
                    })),
                };
            })
            .value();

        const rows = _(subsections)
            .flatMap(subsection => subsection.dataElements)
            .uniqBy(de => de.name)
            .groupBy(de => _(de.name.split(separator)).initial().join(" - "))
            .map((group, groupName) => {
                const firstDeInGroup = _(group).first()?.code || "";
                const groupDescription = getDescription(section.groupDescriptions, dataFormInfo, firstDeInGroup);

                return {
                    groupName: groupName,
                    groupDescription: groupDescription,
                    rows: group.map(de => {
                        return { dataElement: de, deName: _.last(de.name.split(separator)) ?? "", name: de.name };
                    }),
                };
            })
            .value();

        const columns: Column[] = _.orderBy(
            subsections.map(subsection => {
                const columnDescription = getDescription(
                    section.columnsDescriptions,
                    dataFormInfo,
                    subsection.code || ""
                );
                const columnDataElements = rows.flatMap(row => {
                    return subsection.dataElements.filter(de => row.rows.map(r => r.name).includes(de.name));
                });

                return {
                    name: subsection.name,
                    dataElements: columnDataElements,
                    description: columnDescription,
                };
            }),
            [section.sortRowsBy ? section.sortRowsBy : ""]
        );

        const totals = _(columns)
            .map(column => {
                const selectedDataElements = column.dataElements.filter(dataElement =>
                    section.totals?.dataElementsCodes.includes(dataElement.code)
                );

                const columnWithDataElements = _(selectedDataElements)
                    .map((dataElement): Maybe<TotalItem> => {
                        if (dataElement.type !== "NUMBER") return undefined;
                        const categoryOptionCombo = dataElement.categoryCombos.categoryOptionCombos.find(coc => {
                            const columnName = coc.formName ?? coc.name;
                            return columnName === column.name;
                        });
                        if (!categoryOptionCombo) {
                            console.warn(
                                `Cannot found categoryOptionCombo in column ${column.name} for dataElement ${dataElement.code}`
                            );
                            return undefined;
                        }

                        return { dataElement, categoryOptionCombo };
                    })
                    .compact()
                    .value();

                return {
                    columnName: column.name,
                    formula: getFormulaByColumnName(section, column.name) || section.totals?.formula || "",
                    items: columnWithDataElements,
                };
            })
            .value();

        return {
            id: section.id,
            indicators: section.indicators,
            name: section.name,
            columns: columns,
            rows: rows,
            toggle: section.toggle,
            toggleMultiple: section.toggleMultiple,
            texts: section.texts,
            summary: section.totals ? { cellName: section.texts?.totals || "", cells: totals } : undefined,
        };
    }
}

export type Summary = { cells: CellTotal[]; cellName: string };
export type CellTotal = { formula: string; columnName: string; items: TotalItem[] };
export type TotalItem = { dataElement: DataElement; categoryOptionCombo: CategoryOptionCombo };
