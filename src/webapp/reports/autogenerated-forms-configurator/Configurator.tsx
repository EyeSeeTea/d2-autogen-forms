import React, { useEffect, useMemo, useRef, useState } from "react";
import Editor, { Monaco, loader } from "@monaco-editor/react";
import { Dropdown, DropdownProps } from "@eyeseetea/d2-ui-components";
import styled from "styled-components";
import i18n from "../../../locales";
import { Button } from "@material-ui/core";
import { useAppContext } from "../../contexts/app-context";
import { NamedRef } from "../../../domain/common/entities/Ref";
import { DataSet } from "../../../domain/autogenerated-forms-configurator/entities/DataSet";
import { CircularProgress } from "material-ui";
import _ from "lodash";

const AutogeneratedFormConfigurator: React.FC = () => {
    const { compositionRoot } = useAppContext();
    const valueGetter = useRef();

    const [selectedDataSet, setSelectedDataSet] = useState<string>("");
    const [dataSets, setDataSets] = useState<DataSet[]>([]);
    const [value, setValue] = useState<string | undefined>();
    const [isJSONValid, setJsonValidity] = useState<boolean>(false);

    const { code, sections } = useMemo(() => {
        const selectedDS = _.find(dataSets, { id: selectedDataSet });
        if (!selectedDS) return { code: "", sections: [] };

        setValue(!value ? "{}" : value);

        return { code: selectedDS.code, sections: selectedDS.sections };
    }, [dataSets, selectedDataSet, value]);

    useEffect(() => {
        loader
            .init()
            .then((monaco: Monaco) => {
                const sectionCodes = sections.map(section => section.code);
                const schema = {
                    type: "object",
                    properties: {
                        periods: {
                            type: "string",
                        },
                        toggle: {
                            type: "string",
                        },
                        viewType: {
                            enum: ["grid", "grid-with-periods"],
                        },
                    },
                    required: ["periods", "toggle", "viewType"],
                    additionalProperties: false,
                };
                const result = _.map(sectionCodes, code => ({ [code]: schema }));
                const mergedResult = _.merge({}, ...result);

                monaco.languages.json.jsonDefaults.setDiagnosticsOptions({
                    validate: true,
                    schemas: [
                        {
                            uri: "http://autogenerated-forms/configurator.json",
                            fileMatch: ["*"],
                            schema: {
                                type: "object",
                                properties: {
                                    dataSets: {
                                        type: "object",
                                        properties: {
                                            [code]: {
                                                type: "object",
                                                properties: {
                                                    sections: {
                                                        type: "object",
                                                        properties: mergedResult,
                                                        required: sectionCodes,
                                                        additionalProperties: false,
                                                    },
                                                    texts: {
                                                        type: "object",
                                                    },
                                                    viewType: {
                                                        enum: ["grid", "grid-with-periods"],
                                                    },
                                                },
                                                required: ["sections", "texts", "viewType"],
                                            },
                                        },
                                        required: [code],
                                        additionalProperties: false,
                                    },
                                    dataElements: {
                                        type: "object",
                                    },
                                    categoryCombinations: {
                                        type: "object",
                                    },
                                },
                                required: ["dataSets"],
                                additionalProperties: false,
                            },
                        },
                    ],
                });
            })
            .catch(error => console.error("An error occurred during initialization of Monaco: ", error));
    }, [code, sections]);

    function handleEditorValidation(markers: any) {
        if (_.isEmpty(markers)) {
            setJsonValidity(true);
        } else {
            setJsonValidity(false);
        }
    }

    function handleEditorDidMount(_valueGetter: any) {
        valueGetter.current = _valueGetter;
    }

    useEffect(() => {
        compositionRoot.dataStoreConfig.getDataSets().then(dataSets => setDataSets(dataSets));
    }, [compositionRoot.dataStoreConfig]);

    useEffect(() => {
        compositionRoot.dataStoreConfig
            .getFormConfig(code)
            .then(config => code !== "" && setValue(JSON.stringify(config, null, 4)));
    }, [compositionRoot.dataStoreConfig, dataSets, code, selectedDataSet]);

    const dataSetItems = useMemoOptionsFromNamedRef(dataSets);

    const setDataSet = React.useCallback<SingleDropdownHandler>(dataSet => {
        setSelectedDataSet(dataSet ?? "");
    }, []);

    console.log({
        dataSets,
        selectedDataSet,
        code,
        sections,
    });

    return (
        <Container>
            <SingleDropdownStyled
                items={dataSetItems}
                value={selectedDataSet}
                onChange={setDataSet}
                label={i18n.t("Data set")}
                hideEmpty
            />

            <StyledEditor
                loading={<CircularProgress />}
                height="80vh"
                width="60vw"
                language="json"
                defaultLanguage="json"
                defaultValue="{}"
                value={value}
                onChange={setValue}
                options={{ wordWrap: "on", minimap: { enabled: false } }}
                onValidate={handleEditorValidation}
                beforeMount={handleEditorDidMount}
            />

            <ButtonGroup>
                <Button color="primary" variant="contained" disabled={!selectedDataSet || !isJSONValid || !value}>
                    Save
                </Button>
                <Button color="default" variant="contained">
                    Cancel
                </Button>
            </ButtonGroup>
        </Container>
    );
};

export default React.memo(AutogeneratedFormConfigurator);

function useMemoOptionsFromNamedRef(options: NamedRef[]) {
    return React.useMemo(() => {
        return options.map(option => ({ value: option.id, text: option.name }));
    }, [options]);
}

const Container = styled.div`
    padding: 20px;
`;

const SingleDropdownStyled = styled(Dropdown)`
    margin-left: -10px;
    width: 50%;
`;

const StyledEditor = styled(Editor)`
    margin: 40px 0 20px;
    grid-area: auto / 1 / auto / auto;
    padding: 20px;
    border: 1px solid rgb(160, 173, 186);
    border-radius: 3px;
    box-shadow: rgba(48, 54, 60, 0.1) 0px 1px 2px 0px inset;
}
`;

const ButtonGroup = styled.div`
    width: 50%;
    display: grid;
    grid-template-columns: repeat(2, minmax(0, 1fr));
    gap: 0 1rem;
`;

type SingleDropdownHandler = DropdownProps["onChange"];
