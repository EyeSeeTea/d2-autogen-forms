import { ArgumentParser } from "argparse";

import { getCompositionRoot } from "../compositionRoot";
import { D2Api } from "../types/d2-api";
import xlsx from "@eyeseetea/xlsx-populate";
import { GridWithTotalsViewModel, Row } from "../webapp/reports/autogenerated-forms/GridWithTotalsViewModel";
import { DataForm, SectionWithTotals } from "../domain/common/entities/DataForm";
import {
    GridWithCombosViewModel,
    Row as RowCombo,
} from "../webapp/reports/autogenerated-forms/GridWithCombosViewModel";

/*
  npx ts-node src/scripts/translations-template.ts \
  -u "dev.user:xcdBPEh8tbGBDmbP!" \
  --url http://DESKTOP-I6DTCCV.local:8080 \
  --path "./nhwa_module_1_base.xlsm"
 */

async function main() {
    const parser = new ArgumentParser();

    parser.add_argument("-u", "--user-auth", {
        help: "DHIS2 authentication",
        metavar: "USERNAME:PASSWORD",
    });

    parser.add_argument("--url", {
        help: "DHIS2 base URL",
        metavar: "URL",
    });

    parser.add_argument("--path", { help: "path to the json file with all the translations to import" });

    const args = parser.parse_args();

    const [username, password] = args.user_auth.split(":", 2);
    if (!username || !password) return;
    if (!args.path) throw Error(`Invalid value for argument --path`);

    const api = new D2Api({ baseUrl: args.url, auth: { username, password } });
    const compositionRoot = getCompositionRoot(api);
    console.log("Getting metadata...");
    const dataForm = await compositionRoot.dataForms.get({
        dataSetId: "uc8uSqVVt4n",
        period: "2022",
        orgUnitId: "hmZE3mVAZFf",
    });

    await buildExcelModule1(dataForm, args.path);
}

async function buildExcelModule1(dataForm: DataForm, excelPath: string): Promise<void> {
    const firstSectionCode = "NHWA-M1-S1";
    const countrySectionCode = "NHWA-M1-S5";
    const inflowsCode = "NHWA-M1-S8";

    const autogenFormSection = dataForm.sections.find(section => section.code === firstSectionCode);
    const countrySection = dataForm.sections.find(section => section.code === countrySectionCode);
    const inflowSection = dataForm.sections.find(section => section.code === inflowsCode);

    if (!autogenFormSection || !countrySection || !inflowSection) {
        throw Error(`Cannot find section`);
    }

    const excelFile = await xlsx.fromFileAsync(excelPath);

    const viewModel = GridWithTotalsViewModel.get(
        autogenFormSection as SectionWithTotals,
        dataForm.dataElements,
        dataForm.options.dataElements
    );

    const countryViewModel = GridWithCombosViewModel.get(countrySection);
    const flowsViewModel = GridWithCombosViewModel.get(inflowSection);
    console.log("Updating excel file...");
    // Demographic
    const demographic = excelFile.sheet("Demographic");
    updateCellNames(viewModel.rows, demographic, "C", 8);

    // DemographicsDetailed
    const demographicsDetailedSheet = excelFile.sheet("DemographicsDetailed");
    updateCellNames(viewModel.rows, demographicsDetailedSheet, "C", 9);

    // CountryOfTraining
    const countrySheet = excelFile.sheet("CountryOfTraining");
    updateCellCategories(countryViewModel.rows, countrySheet, "C", 8);

    // FacilityOwnershipAndFacility
    const facility = excelFile.sheet("FacilityOwnershipAndFacility");
    updateCellNames(viewModel.rows, facility, "C", 11);

    // Inflows&Outflows
    const flows = excelFile.sheet("Inflows&Outflows");
    updateCellCategories(flowsViewModel.rows, flows, "C", 9);

    // SourceType
    const sourceType = excelFile.sheet("SourceType");
    updateCellNames(viewModel.rows, sourceType, "C", 7);

    // TypeOfContract
    const typeOfContract = excelFile.sheet("TypeOfContract");
    updateCellNames(viewModel.rows, typeOfContract, "C", 11);

    const outputFileName = "output.xlsm";
    await excelFile.toFileAsync(outputFileName);
    console.log(`Excel file saved as ${outputFileName}`);
}

function updateCellCategories(rows: RowCombo[], sheet: xlsx.Sheet, cellColumn: string, startRowNumber: number) {
    rows.forEach((row, rowIndex) => {
        sheet
            .row(rowIndex + startRowNumber)
            .cell(cellColumn)
            .value(row.name);
    });
}

function updateCellNames(gridRows: Row[], sheet: xlsx.Sheet, cellColumn: string, startRowNumber: number) {
    gridRows.forEach((row, rowIndex) => {
        const rowName = row.name.split(" - ")[1];
        const rowWithSpace = row.includePadding ? `${" ".repeat(5 * row.includePadding)} ${rowName}` : rowName;

        sheet
            .row(rowIndex + startRowNumber)
            .cell(cellColumn)
            .value(rowWithSpace);
    });
}

main();
